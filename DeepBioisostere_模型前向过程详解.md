# DeepBioisostere 模型前向过程详解

## 概述

DeepBioisostere 是一个用于片段级分子结构修饰的深度学习模型，能够探索生物等排物（bioisosteres）。该模型通过图神经网络对分子进行编码，并支持基于分子属性（如QED、LogP、分子量等）的条件生成。

## 模型架构概览

```
╔════════════════════════════════════════════════════════════════════════════════╗
║                          DeepBioisostere 模型架构                              ║
╠════════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐                           ║
║  │ 输入分子图   │  │ 正样本片段   │  │ 负样本片段    │                           ║
║  │   (Data)    │  │ (pos_frags) │  │ (neg_frags)  │                           ║
║  └─────┬───────┘  └─────────────┘  └──────────────┘                           ║
║        │                                                                      ║
║  ┌─────▼─────────────────┐  ┌─────────────────────────────┐                   ║
║  │   条件嵌入系统          │  │         片段嵌入             │                   ║
║  │  (QED/LogP/MW/SA)     │  │    (Fragment Embedding)     │                   ║
║  │        │              │  │                             │                   ║
║  │  [属性标准化]           │  │   ┌─────────────────────┐   │                   ║
║  │        │              │  │   │  片段图神经网络      │   │                   ║
║  │  [条件嵌入生成]         │  │   │  (Frag GNN)        │   │                   ║
║  └────────┬──────────────┘  │   └─────────────────────┘   │                   ║
║           │                 └─────────────────────────────┘                   ║
║  ┌────────▼───────────┐                                                       ║
║  │      AMPN          │                                                       ║
║  │  (原子级消息传递)    │   ┌─────────────────────────────────────┐             ║
║  │                    │   │        特征融合与条件注入              │             ║
║  │  [原子特征: 49维]   │   │                                     │             ║
║  │  [化学键特征: 12维] │   │ ampn_emb.x_f = cat([fragment_emb,   │             ║
║  │  [4层消息传递]      │   │                     condition_emb]) │             ║
║  └────────┬───────────┘   └─────────────────────────────────────┘             ║
║           │                                                                   ║
║  ┌────────▼───────────┐                                                       ║
║  │      FMPN          │                                                       ║
║  │  (片段级消息传递)    │                                                       ║
║  │                    │                                                       ║
║  │  [包含条件信息的     │                                                       ║
║  │   片段级交互]       │                                                       ║
║  └────────┬───────────┘                                                       ║
║           │                                                                   ║
║           ▼                                                                   ║
║  ┌─────────────────────────────────────────────────────────────────┐         ║
║  │                    三大预测模块                                   │         ║
║  │                                                                 │         ║
║  │  ┌─────────────┐  ┌─────────────┐  ┌───────────────────┐        │         ║
║  │  │位置评分模块  │  │片段评分模块  │  │  附着预测模块      │        │         ║
║  │  │            │  │            │  │                  │        │         ║
║  │  │[位置选择]   │  │[片段选择]   │  │  [连接位点预测]   │        │         ║
║  │  │     │      │  │     │      │  │        │         │        │         ║
║  │  │  Sigmoid   │  │  Sigmoid   │  │     Sigmoid      │        │         ║
║  │  └─────┬───────┘  └─────┬───────┘  └────────┬────────┘        │         ║
║  └────────┼──────────────────┼───────────────────┼─────────────────┘         ║
║           │                 │                   │                           ║
║           ▼                 ▼                   ▼                           ║
║  ┌────────────────────────────────────────────────────────────────┐         ║
║  │                     损失函数计算                                 │         ║
║  │                                                                │         ║
║  │  pPosLoss + nPosLoss + pFragsLoss + nFragsLoss + attPredLoss   │         ║
║  └────────────────────────────────────────────────────────────────┘         ║
║                                                                              ║
╚════════════════════════════════════════════════════════════════════════════════╝
```

模型主要由以下五个核心组件构成：

1. **消息传递网络 (Message Passing Networks)**
   - AMPN (Atom-Molecule Pair Message Passing Network)
   - FMPN (Fragment-level Message Passing Network)

2. **位置评分模块 (Position Scoring Module)**
   - 确定离开片段的位置

3. **片段评分模块 (Fragment Scoring Module)**
   - 确定插入片段的类型

4. **附着预测模块 (Attachment Prediction Module)**
   - 预测片段与分子的连接位点

5. **条件嵌入系统 (Conditional Embedding System)**
   - 基于分子属性的条件控制

## 前向传播详细流程

```
╔════════════════════════════════════════════════════════════════════════════════╗
║                        DeepBioisostere 前向传播流程                            ║
╠════════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║  第一阶段: 输入数据处理                                                         ║
║  ┌─────────────┐  ┌─────────────┐  ┌──────────────┐                           ║
║  │ 输入分子图   │  │ 正样本片段   │  │ 负样本片段    │                           ║
║  │   (Data)    │  │ (pos_frags) │  │ (neg_frags)  │                           ║
║  └─────┬───────┘  └─────┬───────┘  └──────┬───────┘                           ║
║        │                │                 │                                   ║
║        │                ▼                 ▼                                   ║
║        │         ┌─────────────────────────────┐                              ║
║        │         │     片段嵌入处理             │                              ║
║        │         │  (Fragment Embedding)      │                              ║
║        │         └─────────┬───────────────────┘                              ║
║        │                   │                                                  ║
║        ▼                   │                                                  ║
║  ┌─────────────────────────┼───────────────────────────────┐                  ║
║  │  第二阶段: AMPN 原子级嵌入 │                               │                  ║
║  │                        │                               │                  ║
║  │  ┌─────────────────────▼───────────────────┐           │                  ║
║  │  │        AMPN 消息传递网络                 │           │                  ║
║  │  │                                        │           │                  ║
║  │  │  [原子特征: 49维]                       │           │                  ║
║  │  │  [化学键特征: 12维]                     │           │                  ║
║  │  │  [4层消息传递处理]                      │           │                  ║
║  │  └─────────────────┬───────────────────────┘           │                  ║
║  └────────────────────┼───────────────────────────────────┘                  ║
║                       │                                                      ║
║                       ▼                                                      ║
║  ┌─────────────────────────────────────────────────────────┐                 ║
║  │  第三阶段: 条件嵌入融合 (QED控制核心)                    │                 ║
║  │                                                         │                 ║
║  │  ┌─────────────┐     ┌─────────────────────────────┐    │                 ║
║  │  │ QED/LogP/   │────▶│      条件标准化处理          │    │                 ║
║  │  │ MW/SA 属性  │     │                             │    │                 ║
║  │  └─────────────┘     │ normalized = (x-min)/(max-min) │    │                 ║
║  │                      └─────────────┬───────────────┘    │                 ║
║  │                                    │                    │                 ║
║  │                                    ▼                    │                 ║
║  │                      ┌─────────────────────────────┐    │                 ║
║  │                      │     条件嵌入生成             │    │                 ║
║  │                      │                             │    │                 ║
║  │                      │ condition_emb = cat([...])  │    │                 ║
║  │                      └─────────────┬───────────────┘    │                 ║
║  │                                    │                    │                 ║
║  │                                    ▼                    │                 ║
║  │  ┌─────────────────────────────────────────────────┐    │                 ║
║  │  │           特征融合                               │    │                 ║
║  │  │                                                 │    │                 ║
║  │  │ ampn_emb.x_f = cat([fragment_emb, condition_emb]) │    │                 ║
║  │  └─────────────────┬───────────────────────────────┘    │                 ║
║  └────────────────────┼────────────────────────────────────┘                 ║
║                       │                                                      ║
║                       ▼                                                      ║
║  ┌─────────────────────────────────────────────────────────┐                 ║
║  │  第四阶段: FMPN 片段级消息传递                           │                 ║
║  │                                                         │                 ║
║  │  ┌─────────────────────────────────────────────────┐    │                 ║
║  │  │        FMPN 消息传递网络                         │    │                 ║
║  │  │                                                 │    │                 ║
║  │  │  [处理包含条件信息的片段特征]                    │    │                 ║
║  │  │  [片段间信息交换]                               │    │                 ║
║  │  │  [生成最终分子嵌入 mol_emb]                     │    │                 ║
║  │  └─────────────────┬───────────────────────────────┘    │                 ║
║  └────────────────────┼────────────────────────────────────┘                 ║
║                       │                                                      ║
║                       ▼                                                      ║
║  ┌─────────────────────────────────────────────────────────┐                 ║
║  │  第五阶段: 位置评分 (离开片段预测)                       │                 ║
║  │                                                         │                 ║
║  │  ┌─────────────────────────────────────────────────┐    │                 ║
║  │  │           正样本位置评分                         │    │                 ║
║  │  │                                                 │    │                 ║
║  │  │  scatter_sum → position_model → Sigmoid        │    │                 ║
║  │  └─────────────────┬───────────────────────────────┘    │                 ║
║  │                    │                                    │                 ║
║  │  ┌─────────────────▼───────────────────────────────┐    │                 ║
║  │  │           负样本位置评分                         │    │                 ║
║  │  │                                                 │    │                 ║
║  │  │  scatter_sum → position_model → Sigmoid        │    │                 ║
║  │  └─────────────────┬───────────────────────────────┘    │                 ║
║  │                    │                                    │                 ║
║  │                    ▼                                    │                 ║
║  │  ┌─────────────────────────────────────────────────┐    │                 ║
║  │  │        位置损失计算                              │    │                 ║
║  │  │                                                 │    │                 ║
║  │  │  pPosLoss = -log(pos_scores).mean()           │    │                 ║
║  │  │  nPosLoss = -log(1-neg_scores).mean()         │    │                 ║
║  │  └─────────────────┬───────────────────────────────┘    │                 ║
║  └────────────────────┼────────────────────────────────────┘                 ║
║                       │                                                      ║
║                       ▼                                                      ║
║                       ·                                                      ║
║                       ·  (继续下一阶段...)                                   ║
║                       ·                                                      ║
╚════════════════════════════════════════════════════════════════════════════════╝
```

### 第一阶段：数据嵌入与条件融合

#### 1.1 输入数据处理

模型接收的输入数据 `batch_data` 包含：
- `data`: 主要的分子图数据 (PairData对象)
- `pos`: 正样本片段数据
- `neg`: 负样本片段数据

```python
# 从批次数据中提取组件
data = batch_data["data"]
pos_frags = batch_data["pos"]
neg_frags = batch_data["neg"]
```

#### 1.2 AMPN嵌入

首先通过AMPN (Atom-Molecule Pair Message Passing Network) 对分子进行初始嵌入：

```python
ampn_emb = self.ampn(data)
```

AMPN的功能：
- 处理原子级别的特征 (49维)
- 处理化学键特征 (12维)
- 生成分子的初始嵌入表示

#### 1.3 条件嵌入融合 (QED控制的核心)

**条件嵌入是QED控制机制的关键部分：**

```python
if self.conditioning:
    cond_embeddings = []
    # 遍历所有属性（包括QED）
    for prop in self.properties:
        cond_embeddings.append(batch_data[prop])
    
    # 将所有条件嵌入沿第二维拼接
    condition_embedding = torch.cat(cond_embeddings, dim=1)  # [F, num_props]
    
    # 将条件嵌入与片段特征拼接
    ampn_emb.x_f = torch.cat(
        [ampn_emb.x_f, condition_embedding], dim=1
    )  # [F, F_node+F_frag+num_props]
```

**QED控制机制详解：**

1. **属性标准化**: QED值首先通过 `Conditioner` 类进行标准化处理
   ```python
   # 在conditioning.py中的标准化过程
   normalized_x = (x - min) / (max - min)
   ```

2. **条件嵌入生成**: 
   - QED值被转换为张量并作为条件信息
   - 支持delta模式（目标值与原始值的差异）和绝对值模式

3. **特征融合**: 
   - 条件信息直接拼接到片段特征向量中
   - 这使得后续的消息传递能够感知到QED等属性约束

#### 1.4 FMPN处理

通过FMPN (Fragment-level Message Passing Network) 进行片段级别的消息传递：

```python
mol_emb = self.fmpn(ampn_emb)
```

FMPN的特点：
- 节点特征维度：`mol_node_hid_dim + frag_node_hid_dim + properties_dim * len(properties)`
- 边特征维度：`mol_node_hid_dim * 2`
- 处理片段间的信息交换，同时考虑条件信息

### 第二阶段：位置评分 (离开片段预测)

```
╔════════════════════════════════════════════════════════════════════════════════╗
║                        第六阶段: 片段评分 (插入片段预测)                        ║
╠════════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║  ┌─────────────────────────────────────────────────────────┐                   ║
║  │           正样本片段处理                                 │                   ║
║  │                                                         │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     片段嵌入生成                                 │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  pos_frag_emb = frags_embedding(pos_frags)     │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  │                    │                                    │                   ║
║  │                    ▼                                    │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     片段评分计算                                 │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  concat([removal_vector, frag_emb])            │    │                   ║
║  │  │             ↓                                  │    │                   ║
║  │  │  frag_scoring_model → Sigmoid                  │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  └────────────────────┼────────────────────────────────────┘                   ║
║                       │                                                        ║
║  ┌────────────────────▼────────────────────────────────────┐                   ║
║  │           负样本片段处理                                 │                   ║
║  │                                                         │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     批量片段嵌入                                 │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  neg_frag_emb = frags_embedding(neg_frags)     │    │                   ║
║  │  │  reshape to [num_neg_sample, batch, features]  │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  │                    │                                    │                   ║
║  │                    ▼                                    │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     负样本评分计算                               │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  frags_scoring(removal_vector, neg_frag_emb)   │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  └────────────────────┼────────────────────────────────────┘                   ║
║                       │                                                        ║
║                       ▼                                                        ║
║  ┌─────────────────────────────────────────────────────────┐                   ║
║  │           片段损失计算                                   │                   ║
║  │                                                         │                   ║
║  │  pFragsLoss = -log(pos_frag_scores).mean()             │                   ║
║  │  nFragsLoss = -log(1 - neg_frag_scores).mean()         │                   ║
║  └─────────────────────┬───────────────────────────────────┘                   ║
║                        │                                                       ║
║                        ▼                                                       ║
║  ┌─────────────────────────────────────────────────────────┐                   ║
║  │  第七阶段: 附着位置预测                                 │                   ║
║  │                                                         │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     原子嵌入提取                                 │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  atom_emb_original = mol_emb[original_idx]      │    │                   ║
║  │  │  atom_emb_fragment = frag_emb[fragment_idx]     │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  │                    │                                    │                   ║
║  │                    ▼                                    │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     特征拼接与评分                               │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  concat_query = cat([atom_orig, atom_frag])     │    │                   ║
║  │  │             ↓                                  │    │                   ║
║  │  │  attach_scoring_model → Sigmoid                │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  │                    │                                    │                   ║
║  │                    ▼                                    │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │     附着损失计算                                 │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  允许位置: attachment_scores * allowed          │    │                   ║
║  │  │  禁止位置: (1-attachment_scores) * not_allowed │    │                   ║
║  │  │  attPredLoss = -log(combined).mean()           │    │                   ║
║  │  └─────────────────┬───────────────────────────────┘    │                   ║
║  └────────────────────┼────────────────────────────────────┘                   ║
║                       │                                                        ║
║                       ▼                                                        ║
║  ┌─────────────────────────────────────────────────────────┐                   ║
║  │  第八阶段: 最终输出                                     │                   ║
║  │                                                         │                   ║
║  │  ┌─────────────────────────────────────────────────┐    │                   ║
║  │  │           损失值集合                             │    │                   ║
║  │  │                                                 │    │                   ║
║  │  │  return (pPosLoss, nPosLoss,                   │    │                   ║
║  │  │          pFragsLoss, nFragsLoss,               │    │                   ║
║  │  │          attPredLoss,                          │    │                   ║
║  │  │          pos_mod_scores.mean(),                │    │                   ║
║  │  │          neg_mod_scores.mean(),                │    │                   ║
║  │  │          pos_frag_scores.mean(),               │    │                   ║
║  │  │          neg_frag_scores.mean())               │    │                   ║
║  │  └─────────────────────────────────────────────────┘    │                   ║
║  └─────────────────────────────────────────────────────────┘                   ║
║                                                                                ║
╚════════════════════════════════════════════════════════════════════════════════╝
```

#### 2.1 正样本位置评分

```python
pos_mod_scores, removal_subgraph_vector = self.mod_pos_scoring(
    mol_emb, data.y_pos_subgraph, data.y_pos_subgraph_idx
)
```

位置评分过程：
1. 使用 `scatter_sum` 聚合子图中的片段特征
2. 通过位置评分模型 (`position_scoring_model`) 计算评分
3. 应用Sigmoid函数转换为概率

#### 2.2 负样本位置评分

```python
neg_mod_scores, _ = self.mod_pos_scoring(
    mol_emb, data.y_neg_subgraph, data.y_neg_subgraph_idx
)
```

#### 2.3 位置损失计算

```python
# 正样本位置损失
pPosLoss = (pos_mod_scores + 1e-10).log().mean().neg()

# 负样本位置损失  
nPosLoss = scatter_mean(
    src=(1 - neg_mod_scores + 1e-10).log(), 
    index=data.y_neg_subgraph_batch
).mean().neg()
```

### 第三阶段：片段评分 (插入片段预测)

#### 3.1 正样本片段处理

```python
# 获取正样本片段嵌入
pos_frag_node_emb, pos_frag_graph_emb = self.frags_embedding(pos_frags)
pos_frag_graph_emb = pos_frag_graph_emb.unsqueeze(0)  # [1,B,F]

# 计算正样本片段评分
pos_frag_scores = self.frags_scoring(
    removal_subgraph_vector, pos_frag_graph_emb
)
```

#### 3.2 负样本片段处理

```python
# 获取负样本片段嵌入
_, neg_frag_graph_emb = self.frags_embedding(neg_frags)

# 重塑为 [n,B,F] 格式
neg_frag_graph_emb = neg_frag_graph_emb.view(
    self.num_neg_sample, len(data.smiles), neg_frag_graph_emb.size(-1)
)

# 计算负样本片段评分
neg_frag_scores = self.frags_scoring(
    removal_subgraph_vector, neg_frag_graph_emb
)
```

#### 3.3 片段损失计算

```python
# 正样本片段损失
pFragsLoss = (pos_frag_scores + 1e-12).log().mean().neg()

# 负样本片段损失
nFragsLoss = (1 - neg_frag_scores + 1e-12).log().mean().neg()
```

### 第四阶段：附着位置预测

#### 4.1 附着评分计算

```python
attachment_scores = self.attachment_scoring(
    data, ampn_emb.x_n, pos_frag_node_emb
)
```

附着评分过程：
1. 提取原始分子和新片段中对应原子的嵌入
2. 拼接原子嵌入特征
3. 通过附着评分模型预测连接概率

#### 4.2 附着损失计算

```python
attachment_allowed = mol_emb.compose_allowed_bool
attachment_not_allowed = attachment_allowed == False

attPredLoss = (
    (
        attachment_scores * attachment_allowed
        + ((1 - attachment_scores) * attachment_not_allowed)
        + 1e-12
    )
    .log()
    .mean()
    .neg()
)
```

### 第五阶段：输出与损失返回

模型返回所有损失值和平均评分：

```python
return (
    pPosLoss,        # 正样本位置损失
    nPosLoss,        # 负样本位置损失  
    pFragsLoss,      # 正样本片段损失
    nFragsLoss,      # 负样本片段损失
    attPredLoss,     # 附着预测损失
    pos_mod_scores.mean(),   # 正样本修改位置平均评分
    neg_mod_scores.mean(),   # 负样本修改位置平均评分
    pos_frag_scores.mean(),  # 正样本片段平均评分
    neg_frag_scores.mean(),  # 负样本片段平均评分
)
```

## QED控制机制详解

```
╔════════════════════════════════════════════════════════════════════════════════╗
║                            QED 控制机制流程图                                   ║
╠════════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║  步骤1: 分子属性计算                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                     输入分子                                         │       ║
║  │                                                                     │       ║
║  │  原始分子 (SMILES) ──────┐    目标分子 (SMILES)                      │       ║
║  │         │               │           │                               │       ║
║  │         ▼               │           ▼                               │       ║
║  │  RDKit.MolFromSmiles    │    RDKit.MolFromSmiles                    │       ║
║  │         │               │           │                               │       ║
║  │         ▼               │           ▼                               │       ║
║  │  ┌─────────────┐        │    ┌─────────────┐                        │       ║
║  │  │ calc_QED()  │        │    │ calc_QED()  │                        │       ║
║  │  │ calc_LogP() │        │    │ calc_LogP() │                        │       ║
║  │  │ calc_Mw()   │        │    │ calc_Mw()   │                        │       ║
║  │  │ calc_SA()   │        │    │ calc_SA()   │                        │       ║
║  │  └─────┬───────┘        │    └─────┬───────┘                        │       ║
║  │        │                │          │                                │       ║
║  │        ▼                │          ▼                                │       ║
║  │   原始属性值              │     目标属性值                              │       ║
║  │  [QED_orig, ...]        │    [QED_target, ...]                     │       ║
║  │        │                │          │                                │       ║
║  │        └────────────────┼──────────┘                                │       ║
║  │                         │                                           │       ║
║  │                         ▼                                           │       ║
║  │                   计算属性差值                                        │       ║
║  │               delta = target - original                             │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤2: 属性标准化                                                              ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                   标准化常数定义                                     │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐      │       ║
║  │  │ QED 常数        │  │ LogP 常数       │  │ MW 常数         │      │       ║
║  │  │                │  │                │  │                │      │       ║
║  │  │ max: 1.0       │  │ max: 10.0      │  │ max: 1000.0    │      │       ║
║  │  │ min: 0.0       │  │ min: -5.0      │  │ min: 0.0       │      │       ║
║  │  │                │  │                │  │                │      │       ║
║  │  │ delta_max: 0.4 │  │ delta_max: 3.0 │  │ delta_max:150.0│      │       ║
║  │  │ delta_min:-0.4 │  │ delta_min:-3.0 │  │ delta_min:-150 │      │       ║
║  │  └─────────────────┘  └─────────────────┘  └─────────────────┘      │       ║
║  │                            │                                        │       ║
║  │                            ▼                                        │       ║
║  │                    标准化公式应用                                     │       ║
║  │                                                                     │       ║
║  │            normalized_value = (value - min) / (max - min)           │       ║
║  │                                                                     │       ║
║  │  训练模式: normalized_qed = (qed_delta - (-0.4)) / (0.4 - (-0.4))   │       ║
║  │  生成模式: normalized_qed = (qed_target - 0.0) / (1.0 - 0.0)        │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤3: 条件嵌入生成                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │              条件嵌入向量构建                                          │       ║
║  │                                                                     │       ║
║  │  对于每个属性 prop in [QED, LogP, MW, SA]:                           │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  normalized_prop = norm_fn(prop_value)                     │    │       ║
║  │  │                        ↓                                  │    │       ║
║  │  │  encoded_prop = torch.tensor(normalized_prop).unsqueeze(0) │    │       ║
║  │  │                        ↓                                  │    │       ║
║  │  │  cond_embeddings.append(encoded_prop)                     │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                                                                     │       ║
║  │                            ▼                                        │       ║
║  │                                                                     │       ║
║  │  condition_embedding = torch.cat(cond_embeddings, dim=1)            │       ║
║  │                          ↓                                         │       ║
║  │                   [F, num_properties]                              │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤4: 特征融合                                                                ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                    条件信息注入                                       │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  AMPN 生成的片段嵌入:                                        │    │       ║
║  │  │  ampn_emb.x_f: [F, fragment_features]                      │    │       ║
║  │  │                                                             │    │       ║
║  │  │  条件嵌入:                                                   │    │       ║
║  │  │  condition_embedding: [F, num_properties]                  │    │       ║
║  │  │                                                             │    │       ║
║  │  │                     ↓ 拼接操作 ↓                            │    │       ║
║  │  │                                                             │    │       ║
║  │  │  ampn_emb.x_f = cat([ampn_emb.x_f, condition_embedding])   │    │       ║
║  │  │                                                             │    │       ║
║  │  │  最终特征: [F, fragment_features + num_properties]          │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤5: 条件信息传播                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │            通过 FMPN 进行条件感知的消息传递                           │       ║
║  │                                                                     │       ║
║  │  输入: 包含条件信息的片段特征                                          │       ║
║  │       [F, fragment_dim + QED + LogP + MW + SA]                      │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │           FMPN 片段级消息传递                                │    │       ║
║  │  │                                                             │    │       ║
║  │  │  • 每个片段节点都携带QED等条件信息                           │    │       ║
║  │  │  • 消息传递过程中条件信息参与计算                            │    │       ║
║  │  │  • 邻居片段间的信息交换考虑条件约束                          │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  输出: mol_emb - 包含条件信息的最终分子嵌入                           │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤6: 条件指导的预测                                                          ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                 三大模块的条件感知预测                               │       ║
║  │                                                                     │       ║
║  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐           │       ║
║  │  │位置评分模块  │  │片段评分模块  │  │  附着预测模块        │           │       ║
║  │  │            │  │            │  │                    │           │       ║
║  │  │• QED约束影响│  │• QED约束影响│  │• QED约束间接影响    │           │       ║
║  │  │  位置选择   │  │  片段选择   │  │  (通过原子嵌入)     │           │       ║
║  │  │• 优先选择能│  │• 优先选择能│  │• 选择有利于QED     │           │       ║
║  │  │  改善QED的 │  │  达到目标   │  │  目标的连接位点     │           │       ║
║  │  │  修改位点   │  │  QED的片段 │  │                    │           │       ║
║  │  └─────────────┘  └─────────────┘  └─────────────────────┘           │       ║
║  └─────────────────────────────────────────────────────────────────────┘       ║
║                                                                                ║
╚════════════════════════════════════════════════════════════════════════════════╝
```

### QED属性处理流程

1. **属性计算** (`property.py:calc_QED`)：
   ```python
   def calc_QED(mol: Chem.rdchem.Mol):
       return qed(mol)
   ```

2. **条件器处理** (`conditioning.py`):
   - **标准化常数**：
     ```python
     qed_consts = [1.0, 0.0]  # [max, min]
     delta_qed_consts = [0.4, -0.4]  # delta模式的范围
     ```
   
   - **标准化过程**：
     ```python
     normalized_x = (x - min) / (max - min)
     ```

3. **训练时条件生成**：
   ```python
   def add_cond_to_training(self, ref_smi: SMILES, new_smi: SMILES):
       if self.use_delta:
           original_mol = Chem.MolFromSmiles(ref_smi)
           target_mol = Chem.MolFromSmiles(new_smi)
           value1 = calc_QED(original_mol)
           value2 = calc_QED(target_mol)
           norm_value = norm_fn(value2 - value1)  # QED差值
       else:
           target_mol = Chem.MolFromSmiles(new_smi)
           value = calc_QED(target_mol)
           norm_value = norm_fn(value)  # 绝对QED值
   ```

4. **生成时条件控制**：
   ```python
   def add_cond_to_generation(self, prop_dict: Dict[str, float]):
       for prop, value in prop_dict.items():
           norm_value = norm_fn(value)
           encoded_prop = torch.tensor(norm_value).unsqueeze(0)
   ```

### 条件信息的影响路径

1. **特征层面融合**：
   - QED条件直接拼接到片段特征中
   - 影响所有后续的消息传递和评分计算

2. **位置选择影响**：
   - 条件信息通过FMPN传播到位置评分模块
   - 影响哪些位置被选中进行修饰

3. **片段选择影响**：
   - 条件信息影响片段评分计算
   - 引导模型选择能达到目标QED的片段

4. **附着位点影响**：
   - 虽然附着模块主要基于原子嵌入
   - 但原子嵌入已经包含了条件信息

## 生成时的前向过程

在生成阶段 (`generate.py`)，前向过程略有不同：

```
╔════════════════════════════════════════════════════════════════════════════════╗
║                          DeepBioisostere 生成流程                              ║
╠════════════════════════════════════════════════════════════════════════════════╣
║                                                                                ║
║  步骤1: 输入处理与初始嵌入                                                      ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                     用户输入                                         │       ║
║  │                                                                     │       ║
║  │  输入分子 (SMILES) ──────┐    期望属性值 (QED=0.8, LogP=2.5, ...)    │       ║
║  │         │               │           │                               │       ║
║  │         ▼               │           ▼                               │       ║
║  │  InferenceDataset       │    Conditioner.add_cond_to_generation     │       ║
║  │         │               │           │                               │       ║
║  │         ▼               │           ▼                               │       ║
║  │  分子图数据               │    标准化条件嵌入                          │       ║
║  │  [原子、化学键、片段]      │    [normalized_qed, ...]                 │       ║
║  │         │               │           │                               │       ║
║  │         └───────────────┼───────────┘                               │       ║
║  │                         │                                           │       ║
║  │                         ▼                                           │       ║
║  │                 AMPN + 条件融合                                      │       ║
║  │                 FMPN 消息传递                                        │       ║
║  │                         ↓                                           │       ║
║  │                包含条件信息的分子嵌入                                  │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤2: 位置评分与选择                                                          ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                score_modification_position                          │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  使用位置评分模型预测可修改位置                               │    │       ║
║  │  │                                                             │    │       ║
║  │  │  for each subgraph:                                        │    │       ║
║  │  │    pos_score = position_model(subgraph_features)          │    │       ║
║  │  │    pos_prob = Sigmoid(pos_score)                          │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  概率归一化                                                  │    │       ║
║  │  │                                                             │    │       ║
║  │  │  leaving_probs = F.normalize(pos_scores, p=1, dim=0)       │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤3: 片段评分与BRICS约束                                                     ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │               score_fragment_for_position                           │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  BRICS类型约束检查                                           │    │       ║
║  │  │                                                             │    │       ║
║  │  │  for each subgraph_brics_types:                            │    │       ║
║  │  │    allowed_insertion_types = BRICS_MAPPER.getMapping()     │    │       ║
║  │  │    frag_mask = create_fragment_mask(allowed_types)         │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  候选片段评分                                                │    │       ║
║  │  │                                                             │    │       ║
║  │  │  for each allowed_fragment:                                │    │       ║
║  │  │    frag_score = frags_scoring(removal_vector, frag_emb)    │    │       ║
║  │  │    frag_prob = Sigmoid(frag_score)                         │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  概率归一化                                                  │    │       ║
║  │  │                                                             │    │       ║
║  │  │  inserting_probs = F.normalize(frag_scores, p=1, dim=1)    │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤4: 联合概率采样                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                select_from_joint_prob                               │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  联合概率计算                                                │    │       ║
║  │  │                                                             │    │       ║
║  │  │  if num_sample == "all":                                   │    │       ║
║  │  │    joint_prob = leaving_prob ⊗ inserting_prob             │    │       ║
║  │  │  else:                                                     │    │       ║
║  │  │    top_k_sampling from joint probability                  │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  输出: [(subgraph_idx, fragment_idx, joint_prob), ...]              │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤5: 附着方向选择                                                            ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │            select_attachment_orientation                            │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  BRICS组合规则检查                                           │    │       ║
║  │  │                                                             │    │       ║
║  │  │  allowed_combinations = BRICSModule.enumerate_combinations  │    │       ║
║  │  │  (attach_atoms, brics_types, frag_dummy_info)              │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  附着概率计算                                                │    │       ║
║  │  │                                                             │    │       ║
║  │  │  for each combination:                                      │    │       ║
║  │  │    concat_query = cat([atom_orig_emb, atom_frag_emb])       │    │       ║
║  │  │    attach_score = attach_model(concat_query)                │    │       ║
║  │  │    attach_prob = Sigmoid(attach_score)                      │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  最终概率计算                                                │    │       ║
║  │  │                                                             │    │       ║
║  │  │  final_likelihood = attach_prob * joint_prob               │    │       ║
║  │  │  top_k_selection based on final_likelihood                 │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  └─────────────────────────┬───────────────────────────────────────────┘       ║
║                            │                                                   ║
║                            ▼                                                   ║
║  步骤6: 分子合成                                                                ║
║  ┌─────────────────────────────────────────────────────────────────────┐       ║
║  │                    merge_fragment                                   │       ║
║  │                                                                     │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  BRICS分子合成                                               │    │       ║
║  │  │                                                             │    │       ║
║  │  │  for each selected_plan:                                   │    │       ║
║  │  │    generated_smi = BRICSModule.compose_mols_with_attachment │    │       ║
║  │  │    (original_smi, change_indices, new_frag_smi, attachment)│    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  ┌─────────────────────────────────────────────────────────────┐    │       ║
║  │  │  属性计算与验证                                              │    │       ║
║  │  │                                                             │    │       ║
║  │  │  generated_mol = Chem.MolFromSmiles(generated_smi)          │    │       ║
║  │  │  logp = calc_logP(generated_mol)                            │    │       ║
║  │  │  qed = calc_QED(generated_mol)                              │    │       ║
║  │  │  mw = calc_Mw(generated_mol)                                │    │       ║
║  │  │  sa = calc_SAscore(generated_mol)                           │    │       ║
║  │  └─────────────────────────────────────────────────────────────┘    │       ║
║  │                            ↓                                        │       ║
║  │  输出: DataFrame[INPUT-SMI, GEN-SMI, LOGP, QED, MW, SA, PROB]       │       ║
║  └─────────────────────────────────────────────────────────────────────┘       ║
║                                                                                ║
╚════════════════════════════════════════════════════════════════════════════════╝
```

### 生成流程概览

1. **数据嵌入**：与训练时相同的AMPN和FMPN处理
2. **位置评分**：`score_modification_position`
3. **片段评分**：`score_fragment_for_position`  
4. **联合概率选择**：`select_from_joint_prob`
5. **附着方向选择**：`select_attachment_orientation`
6. **分子合成**：`merge_fragment`

### 关键差异

1. **无负样本**：生成时只处理候选片段，无需负样本对比
2. **BRICS规则约束**：严格遵循BRICS片段化规则
3. **概率采样**：基于模型输出概率进行采样选择

## 模型参数与配置

### 默认超参数

```python
default_args = {
    "mol_node_features": 49,          # 原子特征维度
    "mol_edge_features": 12,          # 化学键特征维度
    "mol_node_hid_dim": 128,          # 原子隐藏层维度
    "mol_edge_hid_dim": 128,          # 化学键隐藏层维度
    "mol_num_emb_layer": 4,           # 分子嵌入层数
    "frag_node_features": 66,         # 片段节点特征维度
    "frag_edge_features": 12,         # 片段边特征维度
    "frag_node_hid_dim": 128,         # 片段节点隐藏层维度
    "frag_edge_hid_dim": 128,         # 片段边隐藏层维度
    "frag_num_emb_layer": 4,          # 片段嵌入层数
    "conditioning": True,             # 启用条件嵌入
    "properties": [],                 # 属性列表
    "properties_dim": 1,              # 每个属性的维度
}
```

### 支持的属性

```python
PROPERTIES = ["logp", "mw", "qed", "sa"]
```

- **logp**: 分子的辛醇-水分配系数
- **mw**: 分子量
- **qed**: 定量估计药物相似性
- **sa**: 合成可及性评分

## 总结

DeepBioisostere的前向过程通过精心设计的多阶段架构，实现了对分子修饰的精确控制。QED等属性的条件控制通过特征层面的融合实现，使模型能够生成满足特定属性要求的分子。整个过程结合了图神经网络的强大表示能力和化学知识约束，为药物发现提供了有力的工具。

关键创新点包括：
1. **层次化的图神经网络架构**：从原子级到片段级的多层次表示
2. **条件嵌入机制**：直接将属性约束融入特征表示
3. **多任务学习框架**：同时优化位置选择、片段选择和附着预测
4. **BRICS规则约束**：确保生成分子的化学合理性

这种设计使得模型不仅能够生成新颖的分子结构，还能精确控制其药物化学属性，为基于片段的药物设计提供了强大的计算工具。